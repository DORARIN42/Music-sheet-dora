<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê³¡ ì¶”ê°€ - ë“œëŸ¼ ì•…ë³´ ë·°ì–´</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            padding: 20px;
            min-height: 100vh;
        }
        .main-container {
            display: flex;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }
        .left-panel {
            flex: 1;
            max-width: 900px;
        }
        .right-panel {
            flex: 1;
            position: sticky;
            top: 20px;
            align-self: flex-start;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        .container { max-width: 100%; margin: 0; }
        .header { display: flex; align-items: center; gap: 20px; margin-bottom: 30px; }
        .back-button { color: #007AFF; text-decoration: none; font-size: 18px; cursor: pointer; }
        h1 { font-size: 28px; }
        .form-group { background-color: #2a2a2a; border-radius: 12px; padding: 25px; margin-bottom: 20px; }
        label { display: block; font-size: 16px; font-weight: 500; margin-bottom: 10px; color: #ccc; }
        input[type="text"], input[type="url"] {
            width: 100%; padding: 12px 15px; font-size: 16px;
            border: 1px solid #444; border-radius: 8px;
            background-color: #1a1a1a; color: white; margin-bottom: 15px;
        }
        input:focus { outline: none; border-color: #007AFF; }
        input[type="file"] {
            width: 100%; padding: 12px; font-size: 16px;
            border: 1px dashed #444; border-radius: 8px;
            background-color: #1a1a1a; color: white; cursor: pointer;
        }
        .youtube-preview { background-color: #2a2a2a; border-radius: 12px; padding: 25px; margin-bottom: 20px; }
        .youtube-preview h2 { font-size: 20px; margin-bottom: 15px; }
        .video-wrapper {
            position: relative; padding-bottom: 56.25%; height: 0;
            overflow: hidden; background-color: #000; border-radius: 8px;
        }
        .video-wrapper iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .timing-section { background-color: #2a2a2a; border-radius: 12px; padding: 25px; margin-bottom: 20px; }
        .timing-section h2 { font-size: 20px; margin-bottom: 15px; }
        .timing-controls {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; gap: 30px;
        }
        .timing-left { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
        .current-time { font-size: 16px; color: #ccc; }
        .timing-list { margin-top: 20px; }
        
        /* íƒ€ì´ë° í…Œì´ë¸” ìŠ¤íƒ€ì¼ */
        .timing-table {
            width: 100%;
            border-collapse: collapse;
            background-color: #222222;
            border-radius: 8px;
            overflow: hidden;
        }
        .timing-table thead {
            background-color: #2a2a2a;
        }
        .timing-table th {
            padding: 4px 10px;
            text-align: center;
            font-size: 14px;
            font-weight: 600;
            color: #ccc;
            border-bottom: 1px solid #3a3a3a;
            border-right: 1px solid #2a2a2a;
        }
        .timing-table th:last-child {
            border-right: none;
        }
        .timing-table td {
            padding: 4px 10px;
            border-bottom: 1px solid #2a2a2a;
            border-right: 1px solid #2a2a2a;
            font-size: 14px;
            text-align: center;
        }
        .timing-table td:last-child {
            border-right: none;
        }
        .timing-table tbody tr:last-child td {
            border-bottom: none;
        }
        .timing-table tbody tr:hover {
            background-color: #2a2a2a;
        }
        .timing-table .time-col {
            width: 60px;
        }
        .timing-table .position-col {
            width: 100px;
            white-space: nowrap;
        }
        .timing-table .lyrics-col {
            flex: 1;
            color: #999;
        }
        .timing-table tbody .lyrics-col {
            text-align: left;
        }
        .timing-table .actions-col {
            width: 50px;
            text-align: center;
        }
        .time-inputs {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .time-input-single {
            width: 60px;
            padding: 2px 4px;
            background: none;
            border: 0;
            outline: 0;
            color: white;
            text-align: center;
            font-size: 14px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: textfield;
        }
        .time-input-single:focus {
            background: #2a2a2a;
        }
        .time-input-single:hover {
            background: #2a2a2a;
        }
        .time-input-single::placeholder {
            color: #666;
        }
        /* ìˆ«ì ì…ë ¥ ì¹¸ í™”ì‚´í‘œ ì œê±° */
        .time-input-single::-webkit-outer-spin-button,
        .time-input-single::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .time-input {
            width: 40px;
            padding: 4px;
            background: transparent;
            border: none;
            color: white;
            border-radius: 4px;
            text-align: center;
            font-size: 14px;
        }
        .time-input:focus {
            outline: none;
            background: #2a2a2a;
        }
        .time-input:hover {
            background: #2a2a2a;
        }
        /* ìˆ«ì ì…ë ¥ ì¹¸ í™”ì‚´í‘œ ì œê±° */
        .time-input::-webkit-outer-spin-button,
        .time-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .time-input[type=number] {
            -moz-appearance: textfield;
        }
        .time-separator {
            color: #999;
        }
        .position-input {
            width: 60px;
            padding: 2px 4px;
            background: none;
            border: 0;
            outline: 0;
            color: white;
            text-align: right;
            font-size: 14px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }
        .position-input:focus {
            background: #2a2a2a;
        }
        .position-input:hover {
            background: #2a2a2a;
        }
        .position-input::placeholder {
            color: #666;
        }
        /* ìˆ«ì ì…ë ¥ ì¹¸ í™”ì‚´í‘œ ì œê±° */
        .position-input::-webkit-outer-spin-button,
        .position-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .position-input[type=number] {
            -moz-appearance: textfield;
        }
        
        .timing-item {
            background-color: #222222; padding: 12px 15px; border-radius: 8px;
            margin-bottom: 10px; display: flex; justify-content: space-between;
            align-items: center; gap: 15px;
        }
        .timing-info { font-size: 16px; display: flex; align-items: center; gap: 10px; flex: 1; }
        .timing-time { color: #007AFF; font-weight: 500; min-width: 50px; }
        .scroll-input {
            background-color: #222222; border: 1px solid #3a3a3a;
            border-radius: 4px; color: white; padding: 4px 8px;
            width: 80px; font-size: 14px; text-align: right;
        }
        .scroll-label { color: #999; font-size: 14px; }
        .btn {
            padding: 12px 24px; font-size: 16px; border: none;
            border-radius: 8px; cursor: pointer; transition: all 0.2s; font-weight: 500;
        }
        .btn-primary { background-color: #2d5a7b; color: white; }
        .btn-primary:hover { background-color: #1d4a6b; }
        .btn-secondary { background-color: #3a3a3a; color: white; }
        .btn-secondary:hover { background-color: #4a4a4a; }
        .btn-add-timing {
            background-color: #252525; color: white; padding: 10px 20px;
            font-size: 14px; border: 1px solid #3a3a3a;
        }
        .btn-delete { background: none; border: none; color: #999; font-size: 18px; cursor: pointer; padding: 5px 10px; }
        .btn-delete:hover { color: #dc3545; }
        .action-buttons { display: flex; gap: 15px; justify-content: space-between; align-items: center; margin-top: 30px; }
        .action-buttons-right { display: flex; gap: 15px; }
        .btn-delete-song { background-color: #dc3545; color: white; }
        .btn-delete-song:hover { background-color: #c82333; }
        .info-message { color: #007AFF; font-size: 13px; margin-top: 10px; }
        .hidden { display: none; }
        
        /* PDF ë¯¸ë¦¬ë³´ê¸° */
        .pdf-preview-section {
            background-color: #2a2a2a;
            border-radius: 12px;
            padding: 25px;
            height: 100%;
        }
        .pdf-preview-section h2 {
            font-size: 20px;
            margin-bottom: 15px;
        }
        .pdf-preview-container {
            position: relative;
            background-color: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            max-height: calc(100vh - 140px);
            overflow: auto;
        }
        .pdf-preview-content {
            position: relative;
        }
        .pdf-ruler {
            position: absolute;
            left: 0;
            top: 0;
            width: 60px;
            height: 100%;
            border-right: 2px solid #007AFF;
            pointer-events: none;
            z-index: 10;
        }
        .ruler-mark {
            position: absolute;
            left: 0;
            width: 100%;
            height: 1px;
            background-color: #007AFF;
            display: flex;
            align-items: center;
        }
        .ruler-label {
            position: absolute;
            left: 5px;
            font-size: 11px;
            color: #007AFF;
            background-color: #1a1a1a;
            padding: 2px 4px;
            border-radius: 3px;
            transform: translateY(-50%);
            font-weight: 600;
        }
        .pdf-pages-wrapper {
            margin-left: 70px;
        }
        .pdf-page-preview {
            margin-bottom: 10px;
            background-color: white;
        }
        .pdf-page-preview canvas {
            display: block;
        }
        .no-pdf-message {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        /* ìë™ íƒ€ì´ë° ìƒì„± ìƒíƒœ ë©”ì‹œì§€ */
        .auto-timing-status {
            background-color: #1a3a1a;
            border: 1px solid #2d5a2d;
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #6ec06e;
            display: none;
        }
        .auto-timing-status.error {
            background-color: #3a1a1a;
            border-color: #5a2d2d;
            color: #ff6b6b;
        }
        .auto-timing-status.show {
            display: block;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- ì™¼ìª½ íŒ¨ë„: ê¸°ì¡´ í¼ë“¤ -->
        <div class="left-panel">
            <div class="container">
                <div class="header">
                    <a class="back-button" href="index.html">â† ë’¤ë¡œ</a>
                    <h1>ê³¡ ì¶”ê°€</h1>
                </div>

                <div class="form-group">
                    <label for="song-title">ê³¡ëª…</label>
                    <input type="text" id="song-title" placeholder="ê³¡ëª…" required>
                    <label for="artist">ì•„í‹°ìŠ¤íŠ¸</label>
                    <input type="text" id="artist" placeholder="ì•„í‹°ìŠ¤íŠ¸" required>
                    <label for="youtube-url">ìœ íŠœë¸Œ URL</label>
                    <input type="url" id="youtube-url" placeholder="https://www.youtube.com/watch?v=..." required>
                    <label for="pdf-file">PDF ì•…ë³´ ì—…ë¡œë“œ</label>
                    <input type="file" id="pdf-file" accept=".pdf" required>
                </div>

                <div class="youtube-preview">
                    <h2>ìœ íŠœë¸Œ ë¯¸ë¦¬ë³´ê¸°</h2>
                    <div class="video-wrapper">
                        <div id="youtube-player"></div>
                    </div>
                </div>

                <div class="timing-section">
                    <h2>íƒ€ì´ë° ì„¤ì •</h2>
                    <div class="auto-timing-status" id="auto-timing-status"></div>

                    <div class="timing-controls">
                        <div class="timing-left">
                            <div class="current-time" id="current-time" style="font-size: 18px; font-weight: 600; color: #ccc; margin-right: 15px;">í˜„ì¬ ì¬ìƒ ì‹œê°„: 0:00</div>
                            <button class="btn btn-add-timing" id="add-timing-btn">+ í¬ì¸íŠ¸ ì¶”ê°€</button>
                            <button class="btn btn-add-timing" id="auto-generate-btn" style="background-color: #1d4a6b; color: white;">ìë™ í¬ì¸íŠ¸ ìƒì„±</button>
                        </div>
                    </div>

                    <div class="timing-list" id="timing-list"></div>
                </div>

                <div class="action-buttons">
                    <div>
                        <button class="btn btn-delete-song" id="delete-song-btn" style="display: none;">ì‚­ì œ</button>
                    </div>
                    <div class="action-buttons-right">
                        <button class="btn btn-primary" id="save-btn">ì €ì¥</button>
                        <button class="btn btn-secondary" onclick="location.href='index.html'">ì·¨ì†Œ</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ì˜¤ë¥¸ìª½ íŒ¨ë„: PDF ë¯¸ë¦¬ë³´ê¸° -->
        <div class="right-panel">
            <div class="pdf-preview-section">
                <h2>PDF ë¯¸ë¦¬ë³´ê¸°</h2>
                <div class="pdf-preview-container" id="pdf-preview-container">
                    <div class="no-pdf-message">PDFë¥¼ ì—…ë¡œë“œí•˜ë©´ ë¯¸ë¦¬ë³´ê¸°ê°€ í‘œì‹œë©ë‹ˆë‹¤</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

    <!-- Firebase Database Manager -->
    <script src="js/firebase-db.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        let player = null, pdfFile = null, pdfPages = [], timingPoints = [];
        let currentVideoId = null, pdfTotalHeight = 0;
        let editMode = false, editSongId = null;
        let youtubePlayer = null;
        let timeUpdateTimer = null;

        async function init() {
            await firebaseDB.init();
            
            if (!firebaseDB.isLoggedIn()) {
                alert('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
                location.href = 'index.html';
                return;
            }
            
            const params = new URLSearchParams(window.location.search);
            editSongId = params.get('edit');
            
            if (editSongId) {
                editMode = true;
                await loadSongForEdit(editSongId);
            }
            
            document.getElementById('youtube-url').addEventListener('input', handleYouTubeUrlChange);
            document.getElementById('pdf-file').addEventListener('change', handlePdfFileChange);
            document.getElementById('add-timing-btn').addEventListener('click', addTimingPoint);
            document.getElementById('auto-generate-btn').addEventListener('click', handleAutoGenerateClick);
            document.getElementById('save-btn').addEventListener('click', saveSong);
        }

        async function loadSongForEdit(songId) {
            try {
                const song = await firebaseDB.getSong(songId);
                if (!song) {
                    alert('ê³¡ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    location.href = 'index.html';
                    return;
                }
                
                document.querySelector('h1').textContent = 'ê³¡ ìˆ˜ì •';
                document.getElementById('save-btn').textContent = 'ìˆ˜ì • ì™„ë£Œ';
                
                const deleteBtn = document.getElementById('delete-song-btn');
                deleteBtn.style.display = 'block';
                deleteBtn.addEventListener('click', async () => {
                    if (confirm(`"${song.title}"ì„(ë¥¼) ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                        try {
                            await firebaseDB.deleteSong(songId);
                            alert('ê³¡ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤');
                            location.href = 'index.html';
                        } catch (error) {
                            console.error('ì‚­ì œ ì‹¤íŒ¨:', error);
                            alert('ê³¡ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                        }
                    }
                });
                
                document.getElementById('song-title').value = song.title;
                document.getElementById('artist').value = song.artist;
                document.getElementById('youtube-url').value = song.youtubeUrl;
                
                currentVideoId = song.youtubeId;
                if (window.YT && window.YT.Player) {
                    initYouTubePlayer(song.youtubeId);
                } else {
                    window.onYouTubeIframeAPIReady = () => initYouTubePlayer(song.youtubeId);
                }
                
                if (song.pdfBlob) {
                    pdfFile = song.pdfBlob;
                    pdfPages = song.pdfPages || [];
                    pdfTotalHeight = pdfPages.length > 0 ? pdfPages[pdfPages.length - 1].endY : 0;
                    
                    const arrayBuffer = await song.pdfBlob.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                    await renderPdfPreview(pdf);
                }
                
                timingPoints = song.timingPoints || [];
                renderTimingList();
                
            } catch (error) {
                console.error('ê³¡ ë¡œë“œ ì‹¤íŒ¨:', error);
                alert('ê³¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                location.href = 'index.html';
            }
        }

        function handleYouTubeUrlChange(e) {
            const videoId = FirebaseDB.extractYouTubeId(e.target.value);
            if (videoId) {
                currentVideoId = videoId;
                
                if (window.YT && window.YT.Player) {
                    initYouTubePlayer(videoId);
                } else {
                    window.onYouTubeIframeAPIReady = () => initYouTubePlayer(videoId);
                }
            }
        }

        function initYouTubePlayer(videoId) {
            if (youtubePlayer) {
                youtubePlayer.destroy();
            }
            
            youtubePlayer = new YT.Player('youtube-player', {
                videoId: videoId,
                events: {
                    'onStateChange': onPlayerStateChange,
                    'onReady': onPlayerReady
                }
            });
        }
        
        function onPlayerReady(event) {
            // ë¹„ë””ì˜¤ ì œëª© ê°€ì ¸ì˜¤ê¸°
            const videoData = event.target.getVideoData();
            const videoTitle = videoData.title;
            
            console.log('YouTube ë¹„ë””ì˜¤ ì œëª©:', videoTitle);
            
            // ì œëª©ì´ ë¹„ì–´ìˆì§€ ì•Šê³ , í˜„ì¬ ì…ë ¥ í•„ë“œê°€ ë¹„ì–´ìˆì„ ë•Œë§Œ ìë™ ì±„ìš°ê¸°
            if (videoTitle && !editMode) {
                const parsed = parseVideoTitle(videoTitle);
                
                if (parsed.title && !document.getElementById('song-title').value) {
                    document.getElementById('song-title').value = parsed.title;
                    console.log('âœ… ê³¡ëª… ìë™ ì…ë ¥:', parsed.title);
                }
                
                if (parsed.artist && !document.getElementById('artist').value) {
                    document.getElementById('artist').value = parsed.artist;
                    console.log('âœ… ì•„í‹°ìŠ¤íŠ¸ëª… ìë™ ì…ë ¥:', parsed.artist);
                }
            }
        }
        
        function parseVideoTitle(title) {
            // ì¼ë°˜ì ì¸ YouTube ìŒì•… ì œëª© íŒ¨í„´ë“¤:
            // 1. "Artist - Title"
            // 2. "Title - Artist"
            // 3. "Artist 'Title'"
            // 4. "Title (Official Music Video)"
            // 5. "[Artist] Title"
            
            let artist = '';
            let songTitle = '';
            
            // ê´„í˜¸ ì•ˆì˜ ë¶ˆí•„ìš”í•œ ì •ë³´ ì œê±° (Official Video, MV, Lyric Video ë“±)
            const cleanTitle = title
                .replace(/\([^)]*(?:official|music video|mv|lyric|audio|visualizer)[^)]*\)/gi, '')
                .replace(/\[[^\]]*(?:official|music video|mv|lyric|audio|visualizer)[^\]]*\]/gi, '')
                .trim();
            
            // íŒ¨í„´ 1: "Artist - Title" ë˜ëŠ” "Title - Artist"
            if (cleanTitle.includes(' - ')) {
                const parts = cleanTitle.split(' - ').map(p => p.trim());
                if (parts.length >= 2) {
                    // ì²« ë²ˆì§¸ê°€ ë” ì§§ìœ¼ë©´ ì•„í‹°ìŠ¤íŠ¸ì¼ ê°€ëŠ¥ì„±ì´ ë†’ìŒ
                    if (parts[0].length < parts[1].length) {
                        artist = parts[0];
                        songTitle = parts[1];
                    } else {
                        artist = parts[1];
                        songTitle = parts[0];
                    }
                }
            }
            // íŒ¨í„´ 2: "[Artist] Title" ë˜ëŠ” "(Artist) Title"
            else if (/^[\[\(][^\]\)]+[\]\)]\s+.+/.test(cleanTitle)) {
                const match = cleanTitle.match(/^[\[\(]([^\]\)]+)[\]\)]\s+(.+)/);
                if (match) {
                    artist = match[1].trim();
                    songTitle = match[2].trim();
                }
            }
            // íŒ¨í„´ 3: ì¸ìš©ë¶€í˜¸ë¡œ ë¬¶ì¸ ì œëª© "Artist 'Title'"
            else if (cleanTitle.includes("'") || cleanTitle.includes('"')) {
                const quoteMatch = cleanTitle.match(/^([^'"]+)['"]([^'"]+)['"]/);
                if (quoteMatch) {
                    artist = quoteMatch[1].trim();
                    songTitle = quoteMatch[2].trim();
                }
            }
            // íŒ¨í„´ì„ ì°¾ì§€ ëª»í•œ ê²½ìš°: ì „ì²´ë¥¼ ê³¡ëª…ìœ¼ë¡œ
            else {
                songTitle = cleanTitle;
            }
            
            return {
                title: songTitle,
                artist: artist
            };
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                startTimeUpdate();
            } else {
                stopTimeUpdate();
            }
        }

        function startTimeUpdate() {
            if (timeUpdateTimer) return;
            
            timeUpdateTimer = setInterval(() => {
                if (youtubePlayer && youtubePlayer.getCurrentTime) {
                    const currentTime = youtubePlayer.getCurrentTime();
                    updateCurrentTimeDisplay(currentTime);
                }
            }, 100);
        }

        function stopTimeUpdate() {
            if (timeUpdateTimer) {
                clearInterval(timeUpdateTimer);
                timeUpdateTimer = null;
            }
        }

        function updateCurrentTimeDisplay(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            document.getElementById('current-time').textContent = 
                `í˜„ì¬ ì¬ìƒ ì‹œê°„: ${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // ìë™ ìƒì„± ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬
        async function handleAutoGenerateClick() {
            console.log('=== ìë™ í¬ì¸íŠ¸ ìƒì„± ë²„íŠ¼ í´ë¦­ ===');
            
            if (!pdfFile) {
                alert('ë¨¼ì € PDF íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”');
                return;
            }
            
            if (!currentVideoId) {
                alert('ë¨¼ì € YouTube URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”');
                return;
            }
            
            if (timingPoints.length > 0) {
                if (!confirm('ê¸°ì¡´ íƒ€ì´ë° í¬ì¸íŠ¸ê°€ ëª¨ë‘ ì‚­ì œë˜ê³  ìƒˆë¡œ ìƒì„±ë©ë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    return;
                }
            }
            
            try {
                showAutoTimingStatus('ğŸ” ì•…ë³´ ì¤„ ê°ì§€ ì¤‘...', false);
                
                // PDF ë¡œë“œ
                const arrayBuffer = await pdfFile.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                
                // ì•…ë³´ ì¤„ ìœ„ì¹˜ ê°ì§€
                console.log('ìë™ ì•…ë³´ ì¤„ ê°ì§€ ì‹œì‘...');
                const staffLines = await detectStaffLines(pdf);
                console.log('ê°ì§€ëœ ì•…ë³´ ì¤„ ê°œìˆ˜:', staffLines.length);
                
                if (staffLines.length === 0) {
                    showAutoTimingStatus('ì•…ë³´ ì¤„ì„ ê°ì§€í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤', true);
                    return;
                }
                
                // íƒ€ì´ë° í¬ì¸íŠ¸ ìƒì„± (ì‹œê°„ì€ 0ì´ˆë¡œ ì´ˆê¸°í™”)
                timingPoints = staffLines.map(item => ({
                    time: 0,
                    scrollY: typeof item === 'object' ? Math.floor(item.scrollY) : Math.floor(item),
                    lyrics: typeof item === 'object' ? (item.lyrics || '') : ''
                }));
                
                renderTimingList();
                console.log(`âœ… ${staffLines.length}ê°œì˜ íƒ€ì´ë° í¬ì¸íŠ¸ê°€ ìë™ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!`);
                
                showAutoTimingStatus(`ğŸµ ${staffLines.length}ê°œì˜ ì•…ë³´ ì¤„ì´ ìë™ìœ¼ë¡œ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤!`, false);
                
                // ê°€ì‚¬ íƒ€ì´ë° ìë™ ìƒì„± ì‹œë„
                await tryAutoGenerateTimingFromLyrics();
                
            } catch (error) {
                console.error('âŒ ìë™ í¬ì¸íŠ¸ ìƒì„± ì‹¤íŒ¨:', error);
                showAutoTimingStatus('ìë™ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', true);
            }
        }

        async function checkAndAutoGenerate(pdf) {
            console.log('=== checkAndAutoGenerate í˜¸ì¶œ ===');
            console.log('pdfFile:', pdfFile ? 'ìˆìŒ' : 'ì—†ìŒ');
            console.log('currentVideoId:', currentVideoId);
            console.log('ê¸°ì¡´ timingPoints:', timingPoints.length);
            
            if (!pdfFile || !currentVideoId) {
                console.log('ì¡°ê±´ ë¯¸ì¶©ì¡±: PDF ë˜ëŠ” YouTube ID ì—†ìŒ');
                return;
            }
            
            if (timingPoints.length > 0) {
                console.log('ì´ë¯¸ íƒ€ì´ë° í¬ì¸íŠ¸ ìˆìŒ - ìë™ ìƒì„± ìŠ¤í‚µ');
                return;
            }
            
            try {
                if (!pdf) {
                    console.log('PDF ë‹¤ì‹œ ë¡œë“œ ì¤‘...');
                    const arrayBuffer = await pdfFile.arrayBuffer();
                    pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                }
                
                console.log('ìë™ ì•…ë³´ ì¤„ ê°ì§€ ì‹œì‘...');
                const staffLines = await detectStaffLines(pdf);
                console.log('ê°ì§€ëœ ì•…ë³´ ì¤„ ê°œìˆ˜:', staffLines.length);
                console.log('ê°ì§€ëœ ìœ„ì¹˜:', staffLines);
                
                if (staffLines.length === 0) {
                    console.log('ì•…ë³´ ì¤„ ê°ì§€ ì‹¤íŒ¨ - í¬ì¸íŠ¸ ìƒì„± ì•ˆ í•¨');
                    return;
                }
                
                timingPoints = staffLines.map(item => ({
                    time: 0,
                    scrollY: typeof item === 'object' ? Math.floor(item.scrollY) : Math.floor(item),
                    lyrics: typeof item === 'object' ? (item.lyrics || '') : ''
                }));
                
                renderTimingList();
                console.log(`âœ… ${staffLines.length}ê°œì˜ íƒ€ì´ë° í¬ì¸íŠ¸ê°€ ìë™ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!`);
                
                showAutoTimingStatus(`ğŸµ ${staffLines.length}ê°œì˜ ì•…ë³´ ì¤„ì´ ìë™ìœ¼ë¡œ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤!`, false);
                
                // ê°€ì‚¬ íƒ€ì´ë° ìë™ ìƒì„± ì‹œë„
                tryAutoGenerateTimingFromLyrics();
                
            } catch (error) {
                console.error('âŒ ìë™ í¬ì¸íŠ¸ ìƒì„± ì‹¤íŒ¨:', error);
            }
        }

        async function handlePdfFileChange(e) {
            pdfFile = e.target.files[0];
            if (!pdfFile) return;
            try {
                const arrayBuffer = await pdfFile.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                pdfPages = [];
                let totalHeight = 0;
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 1.5 });
                    pdfPages.push({
                        pageNum: i, startY: totalHeight,
                        endY: totalHeight + viewport.height, height: viewport.height
                    });
                    totalHeight += viewport.height + 20;
                }
                pdfTotalHeight = totalHeight;
                
                await renderPdfPreview(pdf);
            } catch (error) {
                alert('PDF íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
            }
        }

        async function renderPdfPreview(pdf) {
            const container = document.getElementById('pdf-preview-container');
            container.innerHTML = '';
            
            const content = document.createElement('div');
            content.className = 'pdf-preview-content';
            
            const pagesWrapper = document.createElement('div');
            pagesWrapper.className = 'pdf-pages-wrapper';
            
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 1.5 });
                
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                
                const pageDiv = document.createElement('div');
                pageDiv.className = 'pdf-page-preview';
                pageDiv.appendChild(canvas);
                pagesWrapper.appendChild(pageDiv);
                
                await page.render({
                    canvasContext: context,
                    viewport: viewport
                }).promise;
            }
            
            content.appendChild(pagesWrapper);
            
            const ruler = document.createElement('div');
            ruler.className = 'pdf-ruler';
            ruler.style.height = pdfTotalHeight + 'px';
            
            for (let y = 0; y <= pdfTotalHeight; y += 100) {
                const mark = document.createElement('div');
                mark.className = 'ruler-mark';
                mark.style.top = y + 'px';
                
                const label = document.createElement('div');
                label.className = 'ruler-label';
                label.textContent = y + 'px';
                mark.appendChild(label);
                
                ruler.appendChild(mark);
            }
            
            content.appendChild(ruler);
            container.appendChild(content);
        }

        async function detectStaffLines(pdf) {
            console.log('ğŸ” ë§ˆë”” ì—¬ë°± ê°ì§€ ì‹œì‘ - ì´ í˜ì´ì§€:', pdf.numPages);
            const staffPositions = [];
            let currentY = 0;
            
            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                console.log(`í˜ì´ì§€ ${pageNum} ë¶„ì„ ì¤‘...`);
                const page = await pdf.getPage(pageNum);
                const viewport = page.getViewport({ scale: 1.5 });
                
                console.log(`í˜ì´ì§€ ${pageNum} í¬ê¸°:`, viewport.width, 'x', viewport.height);
                
                const canvas = document.createElement('canvas');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                const context = canvas.getContext('2d');
                
                await page.render({ canvasContext: context, viewport }).promise;
                
                const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                const rowWhiteness = [];
                for (let y = 0; y < canvas.height; y++) {
                    let whiteCount = 0;
                    let totalPixels = 0;
                    
                    const startX = Math.floor(canvas.width * 0.1);
                    const endX = Math.floor(canvas.width * 0.9);
                    
                    for (let x = startX; x < endX; x++) {
                        const i = (y * canvas.width + x) * 4;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        const brightness = (r + g + b) / 3;
                        if (brightness > 200) {
                            whiteCount++;
                        }
                        totalPixels++;
                    }
                    
                    rowWhiteness.push(whiteCount / totalPixels);
                }
                
                const maxWhiteness = Math.max(...rowWhiteness);
                console.log(`í˜ì´ì§€ ${pageNum} - ìµœëŒ€ í°ìƒ‰ ë¹„ìœ¨:`, maxWhiteness.toFixed(3));
                
                const whiteThreshold = 0.92;
                const minGapHeight = 20;
                const maxGapHeight = 100;
                const minStaffDistance = 50;
                
                const startY = (pageNum === 1) ? 150 : 50;
                
                let inGap = false;
                let gapStart = 0;
                let lastStaffY = -minStaffDistance;
                
                for (let y = startY; y < rowWhiteness.length - 50; y++) {
                    if (!inGap && rowWhiteness[y] > whiteThreshold) {
                        inGap = true;
                        gapStart = y;
                    } else if (inGap && rowWhiteness[y] <= whiteThreshold) {
                        const gapHeight = y - gapStart;
                        
                        if (gapHeight >= minGapHeight && 
                            gapHeight <= maxGapHeight &&
                            (gapStart - lastStaffY) >= minStaffDistance) {
                            const gapCenter = Math.floor((gapStart + y) / 2);
                            staffPositions.push(currentY + gapCenter);
                            lastStaffY = gapStart;
                            console.log(`  âœ“ ë§ˆë”” ì—¬ë°± ë°œê²¬: Y=${currentY + gapCenter} (${gapHeight}px ì—¬ë°±)`);
                        }
                        inGap = false;
                    }
                }
                
                currentY += viewport.height + 20;
            }
            
            console.log(`ì´ ${staffPositions.length}ê°œì˜ ë§ˆë”” ë°œê²¬`);
            
            const staffWithLyrics = await extractLyrics(pdf, staffPositions);
            
            return staffWithLyrics;
        }

        async function extractLyrics(pdf, staffPositions) {
            if (!pdf) return staffPositions.map(y => ({ scrollY: y, lyrics: '' }));
            
            console.log('ğŸ”¤ ê°€ì‚¬ ì¶”ì¶œ ì‹œì‘...');
            const allLyrics = [];
            let currentY = 0;
            
            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                
                const canvasViewport = page.getViewport({ scale: 1.5 });
                const textContent = await page.getTextContent();
                const originalViewport = page.getViewport({ scale: 1.0 });
                
                textContent.items.forEach(item => {
                    const text = item.str.trim();
                    if (/[ê°€-í£]/.test(text)) {
                        const yOriginal = originalViewport.height - item.transform[5];
                        const yScaled = yOriginal * 1.5;
                        const y = currentY + yScaled;
                        
                        console.log(`    ğŸ“ "${text}" â†’ Y=${Math.round(y)} (Canvas ì¢Œí‘œ, ì›ë³¸Y=${item.transform[5]})`);
                        allLyrics.push({
                            text: text,
                            x: item.transform[4] * 1.5,
                            y: y
                        });
                    }
                });
                
                currentY += canvasViewport.height + 20;
            }
            
            console.log(`ì´ ${allLyrics.length}ê°œì˜ í•œê¸€ í…ìŠ¤íŠ¸ ë°œê²¬`);
            
            const staffWithLyrics = staffPositions.map((staffY, index) => {
                const nearbyLyrics = allLyrics.filter(lyric => {
                    const distance = lyric.y - staffY;
                    return distance > 0 && distance <= 150;
                });
                
                if (nearbyLyrics.length > 0) {
                    nearbyLyrics.sort((a, b) => a.y - b.y);
                    const closestY = nearbyLyrics[0].y;
                    const sameLine = nearbyLyrics.filter(l => Math.abs(l.y - closestY) < 10);
                    
                    sameLine.sort((a, b) => a.x - b.x);
                    const lyrics = sameLine.map(l => l.text).join(' ');
                    console.log(`  âœ“ ë§ˆë”” Y=${Math.round(staffY)} â†’ ê°€ì‚¬ Y=${Math.round(closestY)} (ê±°ë¦¬: ${Math.round(closestY - staffY)}px) â†’ "${lyrics}"`);
                    return { scrollY: staffY, lyrics: lyrics };
                }
                
                console.log(`  âœ— ë§ˆë”” Y=${Math.round(staffY)} â†’ ê°€ì‚¬ ì—†ìŒ`);
                return { scrollY: staffY, lyrics: '' };
            });
            
            return staffWithLyrics;
        }

        // ========== ìë™ ê°€ì‚¬ íƒ€ì´ë° ìƒì„± ê¸°ëŠ¥ ==========
        
        async function fetchSyncedLyrics(title, artist) {
            // YouTube ë¹„ë””ì˜¤ ê¸¸ì´ ê°€ì ¸ì˜¤ê¸°
            let videoDuration = null;
            if (youtubePlayer && youtubePlayer.getDuration) {
                try {
                    videoDuration = Math.floor(youtubePlayer.getDuration());
                    console.log(`YouTube ë¹„ë””ì˜¤ ê¸¸ì´: ${videoDuration}ì´ˆ`);
                } catch (e) {
                    console.log('YouTube ë¹„ë””ì˜¤ ê¸¸ì´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŒ');
                }
            }
            
            if (!videoDuration) {
                console.log('ë¹„ë””ì˜¤ ê¸¸ì´ë¥¼ ì•Œ ìˆ˜ ì—†ì–´ ê²€ìƒ‰ ë¶ˆê°€');
                return null;
            }
            
            console.log(`ğŸ” LRCLIB ê²€ìƒ‰: ê³¡ëª…="${title}", ì•„í‹°ìŠ¤íŠ¸="${artist}"`);
            
            try {
                // LRCLIB ê²€ìƒ‰ API ì‚¬ìš© (q íŒŒë¼ë¯¸í„°ë¡œ ê²€ìƒ‰)
                const searchUrl = `https://lrclib.net/api/search?q=${encodeURIComponent(title + ' ' + artist)}`;
                console.log('ê²€ìƒ‰ URL:', searchUrl);
                
                const response = await fetch(searchUrl);
                
                if (!response.ok) {
                    console.log(`LRCLIB ê²€ìƒ‰ API ì‹¤íŒ¨: ${response.status}`);
                    return null;
                }
                
                const results = await response.json();
                console.log(`ğŸ“‹ ê²€ìƒ‰ ê²°ê³¼: ${results.length}ê°œ`);
                
                if (results.length === 0) {
                    console.log('ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ');
                    return null;
                }
                
                // ìµœëŒ€ 30ê°œê¹Œì§€ë§Œ ì²˜ë¦¬
                const limitedResults = results.slice(0, 30);
                console.log(`ì²˜ë¦¬í•  ê²°ê³¼: ${limitedResults.length}ê°œ`);
                
                // í›„ë³´ë“¤ ë¶„ì„
                const candidates = [];
                
                for (const result of limitedResults) {
                    // 1. Synced Lyricsê°€ ìˆëŠ”ì§€ í™•ì¸
                    if (!result.syncedLyrics) {
                        console.log(`  âœ— "${result.trackName}" by "${result.artistName}" - Synced Lyrics ì—†ìŒ`);
                        continue;
                    }
                    
                    // 2. Duration ì²´í¬ (ê°€ì¥ ì¤‘ìš”!) - ë¹„ë””ì˜¤ ê¸¸ì´ë¥¼ ì•Œ ë•Œ
                    let durationDiff = 0;
                    if (result.duration) {
                        durationDiff = Math.abs(result.duration - videoDuration);
                        // 2ì´ˆ ì´ìƒ ì°¨ì´ë‚˜ë©´ ì œì™¸
                        if (durationDiff > 2) {
                            console.log(`  âœ— "${result.trackName}" by "${result.artistName}" (${result.duration}ì´ˆ) - Duration ì°¨ì´ ë„ˆë¬´ í¼ (${durationDiff}ì´ˆ)`);
                            continue;
                        }
                    } else {
                        // duration ì •ë³´ê°€ ì—†ìœ¼ë©´ ì œì™¸
                        console.log(`  âœ— "${result.trackName}" by "${result.artistName}" - Duration ì •ë³´ ì—†ìŒ`);
                        continue;
                    }
                    
                    // 3. ì œëª© ìœ ì‚¬ë„ ê³„ì‚° (ë™ì ì¼ ë•Œ ì‚¬ìš©)
                    const titleSimilarity = textSimilarity(title, result.trackName || result.name);
                    const titleContains = normalizeText(result.trackName || result.name).includes(normalizeText(title)) ||
                                         normalizeText(title).includes(normalizeText(result.trackName || result.name));
                    
                    // 4. ì•„í‹°ìŠ¤íŠ¸ëª… ìœ ì‚¬ë„ ê³„ì‚° (ë™ì ì¼ ë•Œ ì‚¬ìš©)
                    const artistSimilarity = textSimilarity(artist, result.artistName);
                    const artistContains = normalizeText(result.artistName).includes(normalizeText(artist)) ||
                                          normalizeText(artist).includes(normalizeText(result.artistName));
                    
                    // Durationì„ ê¸°ì¤€ìœ¼ë¡œ 1ì°¨ ì ìˆ˜, ì œëª©/ì•„í‹°ìŠ¤íŠ¸ëŠ” 2ì°¨ ì ìˆ˜
                    const titleScore = titleSimilarity * 0.6 + (titleContains ? 0.4 : 0);
                    const artistScore = artistSimilarity * 0.6 + (artistContains ? 0.4 : 0);
                    const secondaryScore = titleScore * 0.6 + artistScore * 0.4;
                    
                    candidates.push({
                        result: result,
                        durationDiff: durationDiff,
                        titleSimilarity: titleSimilarity,
                        artistSimilarity: artistSimilarity,
                        titleContains: titleContains,
                        artistContains: artistContains,
                        secondaryScore: secondaryScore,
                        lyrics: parseLRC(result.syncedLyrics)
                    });
                    
                    console.log(`  âœ“ "${result.trackName}" by "${result.artistName}" (${result.duration}ì´ˆ)`);
                    console.log(`    - Duration ì°¨ì´: ${durationDiff}ì´ˆ âœ…`);
                    console.log(`    - ì œëª© ìœ ì‚¬ë„: ${(titleSimilarity * 100).toFixed(0)}% ${titleContains ? '[í¬í•¨]' : ''}`);
                    console.log(`    - ì•„í‹°ìŠ¤íŠ¸ ìœ ì‚¬ë„: ${(artistSimilarity * 100).toFixed(0)}% ${artistContains ? '[í¬í•¨]' : ''}`);
                    console.log(`    - 2ì°¨ ì ìˆ˜: ${(secondaryScore * 100).toFixed(0)}%`);
                }
                
                if (candidates.length === 0) {
                    console.log('ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ê°€ì‚¬ë¥¼ ì°¾ì§€ ëª»í•¨');
                    return null;
                }
                
                // 1ìˆœìœ„: Duration ì°¨ì´ (ASC), 2ìˆœìœ„: ì œëª©/ì•„í‹°ìŠ¤íŠ¸ ì ìˆ˜ (DESC)
                candidates.sort((a, b) => {
                    if (a.durationDiff !== b.durationDiff) {
                        return a.durationDiff - b.durationDiff; // Duration ì°¨ì´ê°€ ì ì€ ê²ƒ ë¨¼ì €
                    }
                    return b.secondaryScore - a.secondaryScore; // Duration ë™ì ì´ë©´ 2ì°¨ ì ìˆ˜ê°€ ë†’ì€ ê²ƒ
                });
                
                const selected = candidates[0];
                
                console.log(`\nğŸ‰ ìµœì  í›„ë³´ ì„ íƒ:`);
                console.log(`  ê³¡ëª…: "${selected.result.trackName}" by "${selected.result.artistName}"`);
                console.log(`  ì•¨ë²”: ${selected.result.albumName || 'N/A'}`);
                console.log(`  Duration ì°¨ì´: ${selected.durationDiff}ì´ˆ (${selected.result.duration}ì´ˆ vs ${videoDuration}ì´ˆ)`);
                console.log(`  ì œëª© ìœ ì‚¬ë„: ${(selected.titleSimilarity * 100).toFixed(0)}%`);
                console.log(`  ì•„í‹°ìŠ¤íŠ¸ ìœ ì‚¬ë„: ${(selected.artistSimilarity * 100).toFixed(0)}%`);
                console.log(`  2ì°¨ ì ìˆ˜: ${(selected.secondaryScore * 100).toFixed(0)}%`);
                console.log(`  ê°€ì‚¬ ë¼ì¸ ìˆ˜: ${selected.lyrics.length}`);
                
                return selected.lyrics;
                
            } catch (error) {
                console.error('LRCLIB ê²€ìƒ‰ ì—ëŸ¬:', error);
                return null;
            }
        }
        
        // í…ìŠ¤íŠ¸ ìœ ì‚¬ë„ ê³„ì‚° í•¨ìˆ˜
        function textSimilarity(str1, str2) {
            const s1 = normalizeText(str1);
            const s2 = normalizeText(str2);
            
            if (s1 === s2) return 1.0;
            if (s1.length === 0 || s2.length === 0) return 0.0;
            
            // Levenshtein Distance ê³„ì‚°
            const matrix = [];
            for (let i = 0; i <= s2.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= s1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= s2.length; i++) {
                for (let j = 1; j <= s1.length; j++) {
                    if (s2.charAt(i - 1) === s1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            const distance = matrix[s2.length][s1.length];
            const maxLength = Math.max(s1.length, s2.length);
            return 1 - distance / maxLength;
        }
        
        function parseLRC(lrcText) {
            if (!lrcText) return [];
            
            const lines = lrcText.split('\n');
            const result = [];
            
            for (const line of lines) {
                const match = line.match(/\[(\d+):(\d+\.\d+)\](.*)/);
                if (match) {
                    const minutes = parseInt(match[1]);
                    const seconds = parseFloat(match[2]);
                    const text = match[3].trim();
                    
                    if (text) {
                        result.push({
                            time: Math.floor(minutes * 60 + seconds),
                            text: text
                        });
                    }
                }
            }
            
            return result;
        }
        
        function normalizeText(text) {
            return text
                .replace(/\([^)]*\)/g, '') // ê´„í˜¸ì™€ ê´„í˜¸ ì•ˆì˜ ë‚´ìš© ì œê±° (ex: "(ì½”ëŸ¬ìŠ¤)" ì œê±°)
                .replace(/\[[^\]]*\]/g, '') // ëŒ€ê´„í˜¸ì™€ ëŒ€ê´„í˜¸ ì•ˆì˜ ë‚´ìš© ì œê±°
                .toLowerCase()
                .replace(/[\s.,\-\/!?;:'"â€œâ€â€˜â€™()\[\]{}]/g, '') // ê³µë°± ë° ëª¨ë“  íŠ¹ìˆ˜ë¬¸ì ì œê±°
                .replace(/[^a-z0-9ã„±-ã…ã…-ã…£ê°€-í£]/g, '') // í•œê¸€, ì˜ë¬¸, ìˆ«ìë§Œ ë‚¨ê¸°ê¸°
                .trim();
        }
        
        function similarity(str1, str2) {
            return textSimilarity(str1, str2);
        }
        
        function matchLyrics(pdfLyrics, syncedLyrics) {
            console.log('ğŸ”— ê°€ì‚¬ ë§¤ì¹­ ì‹œì‘...');
            console.log('PDF ê°€ì‚¬:', pdfLyrics.length, 'ê°œ');
            console.log('Synced ê°€ì‚¬:', syncedLyrics.length, 'ê°œ');
            
            // 1) API ê°€ì‚¬ë“¤ì„ ë„ì–´ì“°ê¸° ì œê±°í•˜ì—¬ ì €ì¥
            const syncedNormalized = syncedLyrics.map((item, index) => ({
                index: index,
                time: item.time,
                originalText: item.text,
                normalizedText: normalizeText(item.text)
            }));
            
            console.log('\nğŸ“„ Synced ê°€ì‚¬ ì˜ˆì‹œ (ì²« 5ê°œ):');
            syncedNormalized.slice(0, 5).forEach((item, i) => {
                console.log(`  [${i}] ${item.time}ì´ˆ: "${item.originalText}" â†’ "${item.normalizedText}"`);
            });
            
            // 2) PDF ê°€ì‚¬ë“¤ë„ ë„ì–´ì“°ê¸° ì œê±°í•˜ì—¬ ì €ì¥
            const pdfNormalized = pdfLyrics.map((item, index) => ({
                index: index,
                scrollY: item.scrollY,
                originalLyrics: item.lyrics,
                normalizedLyrics: normalizeText(item.lyrics)
            }));
            
            console.log('\nğŸ“„ PDF ê°€ì‚¬ ì˜ˆì‹œ (ì²« 5ê°œ):');
            pdfNormalized.slice(0, 5).forEach((item, i) => {
                console.log(`  [${i}] "${item.originalLyrics}" â†’ "${item.normalizedLyrics}"`);
            });
            console.log('');
            
            // 3) ìˆœì°¨ì  ë§¤ì¹­
            const matched = [];
            const usedPdfIndices = new Set(); // ì´ë¯¸ ë§¤ì¹­ëœ PDF ê°€ì‚¬ ì¶”ì 
            
            // ê° Synced ê°€ì‚¬ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬
            for (const syncedItem of syncedNormalized) {
                // Synced ê°€ì‚¬ê°€ ë„ˆë¬´ ì§§ìœ¼ë©´ ìŠ¤í‚µ ("ë‹¤..." ê°™ì€ ê²½ìš° ì˜¤ë§¤ì¹­ ë°©ì§€)
                if (syncedItem.normalizedText.length < 3) {
                    console.log(`  âŠ˜ Synced[${syncedItem.index}] "${syncedItem.originalText}" - ë„ˆë¬´ ì§§ì•„ì„œ ìŠ¤í‚µ (${syncedItem.normalizedText.length}ì)`);
                    continue;
                }
                
                // PDF ê°€ì‚¬ë“¤ì„ ìˆœì„œëŒ€ë¡œ í™•ì¸
                for (let i = 0; i < pdfNormalized.length; i++) {
                    const pdfItem = pdfNormalized[i];
                    
                    // ì´ë¯¸ ë§¤ì¹­ëœ PDF ê°€ì‚¬ëŠ” ìŠ¤í‚µ
                    if (usedPdfIndices.has(pdfItem.index)) {
                        continue;
                    }
                    
                    // PDF ê°€ì‚¬ì˜ ì´ˆë°˜ ë¶€ë¶„ì´ Synced ê°€ì‚¬ë¡œ ì‹œì‘í•˜ëŠ”ì§€ í™•ì¸
                    if (pdfItem.normalizedLyrics.startsWith(syncedItem.normalizedText)) {
                        // ë§¤ì¹­ ì„±ê³µ! (1ì´ˆ ì „ìœ¼ë¡œ ì„¤ì •, ìµœì†Œ 0ì´ˆ)
                        const adjustedTime = Math.max(0, syncedItem.time - 1);
                        
                        matched.push({
                            scrollY: pdfItem.scrollY,
                            time: adjustedTime,
                            lyrics: pdfItem.originalLyrics,
                            matchedWith: syncedItem.originalText
                        });
                        
                        usedPdfIndices.add(pdfItem.index);
                        console.log(`  âœ“ ë§¤ì¹­: PDF[${pdfItem.index}] "${pdfItem.originalLyrics.substring(0, 20)}..." â† Synced[${syncedItem.index}] ${syncedItem.time}ì´ˆ â†’ ${adjustedTime}ì´ˆ "${syncedItem.originalText}"`);
                        break; // ë‹¤ìŒ Synced ê°€ì‚¬ë¡œ ì´ë™
                    }
                }
            }
            
            // ë§¤ì¹­ë˜ì§€ ì•Šì€ PDF ê°€ì‚¬ë“¤ì€ ì‹œê°„ 0ìœ¼ë¡œ ì¶”ê°€
            for (const pdfItem of pdfNormalized) {
                if (!usedPdfIndices.has(pdfItem.index)) {
                    matched.push({
                        scrollY: pdfItem.scrollY,
                        time: 0,
                        lyrics: pdfItem.originalLyrics,
                        matchedWith: null
                    });
                    console.log(`  âœ— ë§¤ì¹­ ì‹¤íŒ¨: PDF[${pdfItem.index}] "${pdfItem.originalLyrics}"`);
                }
            }
            
            // scrollY ìˆœì„œëŒ€ë¡œ ì •ë ¬
            matched.sort((a, b) => a.scrollY - b.scrollY);
            
            const successCount = matched.filter(m => m.time > 0).length;
            console.log(`\në§¤ì¹­ ì™„ë£Œ: ${successCount}/${matched.length}`);
            return matched;
        }
        
        function showAutoTimingStatus(message, isError = false) {
            const statusEl = document.getElementById('auto-timing-status');
            statusEl.textContent = message;
            statusEl.className = 'auto-timing-status show';
            if (isError) {
                statusEl.classList.add('error');
            }
            
            setTimeout(() => {
                statusEl.classList.remove('show');
            }, 5000);
        }
        
        async function tryAutoGenerateTimingFromLyrics() {
            console.log('ğŸ¯ ìë™ íƒ€ì´ë° ìƒì„± ì‹œë„...');
            
            const title = document.getElementById('song-title').value.trim();
            const artist = document.getElementById('artist').value.trim();
            
            if (!title || !artist) {
                console.log('ì œëª© ë˜ëŠ” ì•„í‹°ìŠ¤íŠ¸ ì •ë³´ ì—†ìŒ - ìŠ¤í‚µ');
                return;
            }
            
            if (timingPoints.length === 0 || !timingPoints.some(p => p.lyrics)) {
                console.log('PDF ê°€ì‚¬ ì •ë³´ ì—†ìŒ - ìŠ¤í‚µ');
                return;
            }
            
            if (timingPoints.some(p => p.time > 0)) {
                console.log('ì´ë¯¸ íƒ€ì´ë°ì´ ì„¤ì •ë˜ì–´ ìˆìŒ - ìŠ¤í‚µ');
                return;
            }
            
            try {
                showAutoTimingStatus('ğŸ” ì˜¨ë¼ì¸ ê°€ì‚¬ ê²€ìƒ‰ ì¤‘...', false);
                
                const syncedLyrics = await fetchSyncedLyrics(title, artist);
                
                if (!syncedLyrics || syncedLyrics.length === 0) {
                    console.log('ì˜¨ë¼ì¸ ê°€ì‚¬ ì—†ìŒ - ìë™ íƒ€ì´ë° ìƒì„± ë¶ˆê°€');
                    showAutoTimingStatus('ì˜¨ë¼ì¸ ê°€ì‚¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', true);
                    return;
                }
                
                const pdfLyrics = timingPoints.map(p => ({
                    scrollY: p.scrollY,
                    lyrics: p.lyrics
                })).filter(p => p.lyrics);
                
                const matched = matchLyrics(pdfLyrics, syncedLyrics);
                
                let matchedCount = 0;
                for (const matchedItem of matched) {
                    const pointIndex = timingPoints.findIndex(p => 
                        p.scrollY === matchedItem.scrollY && p.lyrics === matchedItem.lyrics
                    );
                    
                    if (pointIndex !== -1 && matchedItem.time > 0) {
                        timingPoints[pointIndex].time = matchedItem.time;
                        matchedCount++;
                    }
                }
                
                // ìœ„ì¹˜ ìˆœìœ¼ë¡œ ì •ë ¬
                timingPoints.sort((a, b) => a.scrollY - b.scrollY);
                renderTimingList();
                
                if (matchedCount > 0) {
                    showAutoTimingStatus(`ğŸ‰ ${matchedCount}ê°œì˜ íƒ€ì´ë°ì´ ìë™ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!`, false);
                    console.log(`âœ… ìë™ íƒ€ì´ë° ìƒì„± ì™„ë£Œ: ${matchedCount}ê°œ`);
                } else {
                    showAutoTimingStatus('ê°€ì‚¬ ë§¤ì¹­ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', true);
                    console.log('ë§¤ì¹­ëœ ê°€ì‚¬ ì—†ìŒ - íƒ€ì´ë° ìƒì„± ì•ˆ ë¨');
                }
                
            } catch (error) {
                console.error('ìë™ íƒ€ì´ë° ìƒì„± ì‹¤íŒ¨:', error);
                showAutoTimingStatus('ìë™ íƒ€ì´ë° ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', true);
            }
        }

        function addTimingPoint() {
            let currentTime = 0;
            
            if (youtubePlayer && youtubePlayer.getCurrentTime) {
                currentTime = Math.floor(youtubePlayer.getCurrentTime());
            }
            
            const timeInput = prompt('íƒ€ì´ë° í¬ì¸íŠ¸ì˜ ì‹œê°„ì„ ì…ë ¥í•˜ì„¸ìš”\n\nì˜ˆì‹œ:\n- 0444 â†’ 4ë¶„ 44ì´ˆ\n- 145 â†’ 1ë¶„ 45ì´ˆ\n- 45 â†’ 45ì´ˆ', currentTime.toString());
            if (!timeInput) return;
            
            const time = parseTimeInput(timeInput);
            if (time === null) {
                alert('ì˜¬ë°”ë¥¸ í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•˜ì„¸ìš”\n\nì˜ˆì‹œ:\n- 0444 (4ë¶„ 44ì´ˆ)\n- 145 (1ë¶„ 45ì´ˆ)\n- 45 (45ì´ˆ)');
                return;
            }
            
            timingPoints.push({ time: time, scrollY: 0, lyrics: '' });
            // ìœ„ì¹˜ ìˆœìœ¼ë¡œ ì •ë ¬
            timingPoints.sort((a, b) => a.scrollY - b.scrollY);
            renderTimingList();
        }
        
        function parseTimeInput(input) {
            const num = input.replace(/\D/g, '');
            if (!num) return null;
            
            if (num.length <= 2) {
                return parseInt(num);
            } else if (num.length === 3) {
                const min = parseInt(num[0]);
                const sec = parseInt(num.substring(1));
                return min * 60 + sec;
            } else {
                const min = parseInt(num.substring(0, num.length - 2));
                const sec = parseInt(num.substring(num.length - 2));
                return min * 60 + sec;
            }
        }

        function renderTimingList() {
            const listEl = document.getElementById('timing-list');
            listEl.innerHTML = '';
            
            if (timingPoints.length === 0) {
                listEl.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">íƒ€ì´ë° í¬ì¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
                return;
            }
            
            // í…Œì´ë¸” ìƒì„±
            const table = document.createElement('table');
            table.className = 'timing-table';
            
            // í…Œì´ë¸” í—¤ë”
            table.innerHTML = `
                <thead>
                    <tr>
                        <th class="time-col">ì‹œê°„</th>
                        <th class="position-col">ìœ„ì¹˜</th>
                        <th class="lyrics-col">ê°€ì‚¬</th>
                        <th class="actions-col"></th>
                    </tr>
                </thead>
                <tbody></tbody>
            `;
            
            const tbody = table.querySelector('tbody');
            
            timingPoints.forEach((point, index) => {
                const minutes = Math.floor(point.time / 60);
                const seconds = point.time % 60;
                
                const tr = document.createElement('tr');
                
                // ì…ë ¥ìš© ìˆ«ì (ë¶„ì´ˆ í˜•ì‹: 444 = 4ë¶„ 44ì´ˆ)
                const timeAsNumber = minutes * 100 + seconds;
                
                tr.innerHTML = `
                    <td class="time-col">
                        <input type="number" class="time-input-single" data-time="${timeAsNumber}" value="${timeAsNumber}" placeholder="0" />
                    </td>
                    <td class="position-col">
                        <input type="number" class="position-input" value="${point.scrollY}" /><span style="color: #999; margin-left: 2px;">px</span>
                    </td>
                    <td class="lyrics-col">${point.lyrics || ''}</td>
                    <td class="actions-col">
                        <button class="btn-delete">Ã—</button>
                    </td>
                `;
                
                // ì‹œê°„ ì…ë ¥ ì´ë²¤íŠ¸ (ìˆ«ì ì…ë ¥, í‘œì‹œëŠ” 00:00 í˜•ì‹)
                const timeInput = tr.querySelector('.time-input-single');
                
                // í¬ì»¤ìŠ¤ ì‹œ ìˆ«ìë§Œ í‘œì‹œ
                timeInput.addEventListener('focus', (e) => {
                    const timeNum = parseInt(e.target.dataset.time) || 0;
                    e.target.value = timeNum || '';
                });
                
                timeInput.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value) || 0;
                    
                    // ìˆ«ìë¥¼ ì´ˆë¡œ ë³€í™˜ (444 â†’ 4ë¶„ 44ì´ˆ = 284ì´ˆ)
                    let totalSeconds = 0;
                    
                    if (value <= 59) {
                        // 59 ì´í•˜: ì´ˆë¡œ ê°„ì£¼
                        totalSeconds = value;
                    } else {
                        // 60 ì´ìƒ: ë§ˆì§€ë§‰ 2ìë¦¬ë¥¼ ì´ˆ, ë‚˜ë¨¸ì§€ë¥¼ ë¶„ìœ¼ë¡œ
                        const min = Math.floor(value / 100);
                        const sec = value % 100;
                        totalSeconds = min * 60 + sec;
                    }
                    
                    timingPoints[index].time = totalSeconds;
                    e.target.dataset.time = value;
                });
                
                // í¬ì»¤ìŠ¤ ì•„ì›ƒ ì‹œ 00:00 í˜•ì‹ìœ¼ë¡œ í‘œì‹œ (ë¶„ë„ 2ìë¦¬)
                timeInput.addEventListener('blur', (e) => {
                    const totalSeconds = timingPoints[index].time;
                    const min = Math.floor(totalSeconds / 60);
                    const sec = totalSeconds % 60;
                    e.target.value = `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
                    
                    // ìœ„ì¹˜ ìˆœìœ¼ë¡œ ì •ë ¬
                    timingPoints.sort((a, b) => a.scrollY - b.scrollY);
                    renderTimingList();
                });
                
                // ìœ„ì¹˜ ì…ë ¥ ì´ë²¤íŠ¸
                tr.querySelector('.position-input').addEventListener('input', (e) => {
                    timingPoints[index].scrollY = parseInt(e.target.value) || 0;
                });
                
                tr.querySelector('.position-input').addEventListener('blur', () => {
                    // ìœ„ì¹˜ ìˆœìœ¼ë¡œ ì •ë ¬
                    timingPoints.sort((a, b) => a.scrollY - b.scrollY);
                    renderTimingList();
                });
                
                // ì‚­ì œ ë²„íŠ¼
                tr.querySelector('.btn-delete').addEventListener('click', () => {
                    timingPoints.splice(index, 1);
                    // ìœ„ì¹˜ ìˆœìœ¼ë¡œ ì •ë ¬
                    timingPoints.sort((a, b) => a.scrollY - b.scrollY);
                    renderTimingList();
                });
                
                tbody.appendChild(tr);
            });
            
            listEl.appendChild(table);
        }

        async function saveSong() {
            const title = document.getElementById('song-title').value.trim();
            const artist = document.getElementById('artist').value.trim();
            const youtubeUrl = document.getElementById('youtube-url').value.trim();
            
            if (!title || !artist || !youtubeUrl || !pdfFile) {
                alert('ëª¨ë“  í•„ìˆ˜ í•­ëª©ì„ ì…ë ¥í•˜ì„¸ìš”');
                return;
            }
            if (timingPoints.length === 0) {
                alert('ìµœì†Œ 1ê°œ ì´ìƒì˜ íƒ€ì´ë° í¬ì¸íŠ¸ë¥¼ ì¶”ê°€í•˜ì„¸ìš”');
                return;
            }
            
            try {
                if (editMode && editSongId) {
                    await firebaseDB.updateSong(editSongId, {
                        title, artist, youtubeUrl, youtubeId: currentVideoId,
                        pdfBlob: pdfFile, pdfPages, timingPoints
                    });
                    alert('ê³¡ì´ ì„±ê³µì ìœ¼ë¡œ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤!');
                    location.href = `sheet.html?id=${editSongId}`;
                } else {
                    await firebaseDB.addSong({
                        title, artist, youtubeUrl, youtubeId: currentVideoId,
                        pdfBlob: pdfFile, pdfPages, timingPoints
                    });
                    alert('ê³¡ì´ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!');
                    location.href = 'index.html';
                }
            } catch (error) {
                console.error('ì €ì¥ ì‹¤íŒ¨:', error);
                alert('ê³¡ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
            }
        }

        init();
    </script>
</body>
</html>
